---
layout:     post   				    
title:    数据结构（1）  				 
subtitle:       #副标题
date:       2018-7-10			   	# 时间
author:     BY 		Cc1over				# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 数据结构
---

## 数据结构
数据结构是相互之间存在一种或多种特定关系的数据元素的集合。或按照一定逻辑关系组织，并按一定存储方式存储的数据的集合，且需要定义一系列运算。逻辑结构、存储结构和运算合称为三要素。表示为：
~~~
      Data_Structure = (D,R)
    其中D为元素有限集，R为关系有限集
~~~
### 一、数据结构基本概念
#### 1、数据
* 数据指的是能输入到计算机中，并能被计算机程序处理的对象。
* 对于数据类型（整型、实型等），可以进行数值计算；<br>
  对于字符数据类型（声音、图像、视频等可通过编码转化为字符数据），可以进行非数值处理。
#### 2、数据元素
* 数据元素指组成数据的、有意义的基本单位，也被称为记录。
* 如：一部电影里面的女主就是数据元素
#### 3、数据项
* 数据项是数据不可分割的最小单位，一个数据元素可以由若干数据项组成。
* 如：一部电影里面女主的姓名，性别等都是数据项。
#### 4、数据对象
* 数据对象指性质相同的数据元素的集合，是数据的子集；
* 数据对象简称数据<br>
  Q：什么是性质相同呢？<br>
  A：性质相同指数据元素具有相同数量和类型的数据项<br>
  如一部电影中每个角色（数据元素）都有姓名、性别（数据项），这些角色（数据元素）构成了一部电影，那么这部电影所有人物的集合我们可以想象成是一个数据对象。
#### 5、数据结构
* 数据结构指互相之间存在一种或多种特定关系的数据元素的集合；
* 数据结构 = 数据元素 + 关系
  还得用上面的例子，一部电影可以想象成是一个数据结构，是由一个个人物（数据元素）和一个个串联的任务情节（关系）组成的。
###  逻辑结构和物理结构
#### 逻辑结构
* 逻辑结构指数据对象中数据元素之间的相互关系
* 逻辑结构分为 集合结构、线性结构、树形结构 和 图形结构<br>
  1) 集合结构：其中的数据元素除同属于一个集合外，之间没有其他关系<br>
  2) 线性结构：其中的数据元素之间是一对一的关系<br>
  3) 树形结构：其中的数据元素之间存在一对多的层次关系<br>
  4) 图形结构：其中的数据元素之间存在多对多的关系
#### 物理结构
* 物理结构指数据的逻辑结构在计算机中的存储形式
* 实际就是如何将数据元素存储到计算机存储器中。这里的存储器主要针对内存而言，像硬盘等外部存储器的数据组织通常使用文件结构来描述；
* 数据元素的存储结构形式有：<br>
  1) 顺序存储：<br>
把数据元素存放在地址连续的的存储单元里，其数据间的逻辑关系和物理关系一致
  2) 链式存储：<br>
链式存储结构：把数据元素存放在任意的存储单元里，这组存储单元可以是连续的也可以是不连       续的。数据元素的存储关系不反映其逻辑关系，用指针存放数据元素的地址，我们通过地址可以      找到相关联数据元素的位置。
### 抽象数据类型
Q1：什么是数据类型？<br>
A1：数据类型指一组性质相同的值的集合及定义在此集合上的一些操作的总称。数据类型按照值的不同进行划分。在高级语言中，每个变量、常量、表达式都有各自取值范围。类型就用来说明变量或表达式的取值范围和所进行的操作。计算机的内存是有限的，如果只是单纯计算 1+1 =2这样的整型数字运算，我们不需要开辟很大的内存空间，只要满足相应需求的内存空间就可以了。于是计算机领域的前辈们对数据进行分类，不同的数据类型拥有各自的取值范围。这样就可以更好利用有限的内存空间。<br>
例如 C 语言中，数据类型可以分两类：<br>
* 原子类型：不可再分割的基本类型。如整型、实型、字符型等基本数据类型；
* 结构类型：由若干类型组成，可再分解。如整型数组就是由若干整型数据组成的。

Q2：那么为什么要把数据类型抽象出来呢？
A2：不同的计算机有不同的硬件系统，所以需要程序语言最终通过编译器或解释器转化成计算机能够识别的底层语言。然而在我们使用高级语言开发时，如计算 1+1 ，不管最终程序运行在什么计算机上，我们的目的只是为了实现 2 个整型数字的运算，不需要详细知道 CPU 为了实现 1+1 进行了几次开关操作。但无论什么计算机、什么计算机语言都会面临如整数运算这样的操作，那么可以考虑把它们抽象出来，只保留实现目标所必需的信息。

Q3：抽象数据类型是什么？
A3：抽象数据类型（Abstract Data Type, ADT）:指一个数学模型及定义在该模型上的一组操作。抽象数据类型的定义仅取决于他的一组逻辑特性，与其在计算机内部如何表示和实现无关。
简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。

Q4： 抽象数据类型有什么意义？
A4："抽象"的意义在于数据类型的数学抽象特性。一个抽象数据类型定义了一个数据对象、数据对象中各数据元素之间的关系及对数据元素的操作。<br>
### 算法和算法分析
#### 算法
**：是对特定问题求解步骤的一种描述，在计算机中表示为指令的有限序列，并且每一条指令表示一个或多个操作。（算法是描述解决问题的方法）**
算法的5个特性：
（1）有穷性：一个算法总是（对于任何合法的输入值）在执行有穷步之后结束，且每一步都可在有穷时间内完成。（有穷性指合理的、可接受的）
（2）确定性：算法中每一条指令必须有确切的含义，读者理解时不会产生二义性。并且，在任何条件下，
算法只有唯一的一条执行路径，即对相同的输入只能得到相同的输出。
（3）可行性：一个算法能行的，即算法中描述的操作都是可以通过已经实现的基本运算执行有限次来实现的。
（4）输入：一个算法有零个或多个的输入，这些输入来自于某个特定的对象的集合。
（5）输出：一个算法有一个或多个的输出，这些输出是输入有着某些特定关系的量。
**设计的要求：**
（1）正确性：算法应满足具体问题的需求。
“正确”大体可分为四个层次：a.程序不含语法错误；b.程序对于几组输入数据能够得出满足规格说明要求的
结果；c.程序对于精心选择的典型、苛刻而带有刁难性的几组输入数据能够得出满足规格说明要求的结果；
d.程序对于一切合法的输入数据都能产生满足规格说明要求的结果。（通常c层意义的正确性作为衡量一个程序是否合格的标准）。
（2）可读性：算法主要是为了人的阅读与交流，其次才是机器执行。可读性好有助于人对算法的理解。
（3）健壮性：当输入数据非法时，算法也能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果。
（4）效率与低存储量需求：效率指的是算法执行的时间，执行时间短的算法效率高；存储量需求指算法执行过程中所需要的最大存储空间。
#### 算法分析
1、事后统计方法：这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。
2、事前分析估算方法 ：在计算机程序编制前，依据统计方法对算法进行估算。

**的渐近增长：**两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n>N，f(n)总是比g(n)大，那么，我们说f(n)的增长渐近快于g(n)。

**算法复杂度分析：**
在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，记作：T(n)=O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称时间复杂度。其中f(n)是问题规模n的某个函数。

**常见的时间复杂度所消耗时间的大小排列：**
![](https://img-blog.csdn.net/20170801203851752?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWlzaGl6dW9mZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

**推导大O阶的方法：**
（1）用常数1取代运行时间中所有的加法常数。
（2）在修改后的运行次数函数中，只保留最高阶项。
（3）如果最高阶项存在且不是1，则去除与这个项相乘的常数。

**算法的空间复杂度：**
通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n)=O(f(n))，其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数。

**注意：通常，我们都是使用“时间复杂度”来指运行时间的需求，使用“空间复杂度”指空间需求。当不用限定词地使用“复杂度”，通常指时间复杂度。**
### 线性表
线性表（线性结构）是包含n个相同性质数据元素的有限序集。它的基本特征是，在数据元素的非空有限集中，
  1) 存在唯一的第一个元素
  2) 存在唯一的最后的元素
  3) 除最后元素外，其他数据元素均有唯一的直接后继
  4) 除第一个元素外，其他元素仅有唯一的直接前驱
#### 线性表的两种表示形式
* 顺序表示（其实就是数组）
~~~
define maxsize 
typedef struct {
    ElemType elem[maxsize]; // 线性表占用的数组空间
    int last; // 记录线性表中最后一个元素在数组elem[]中的位置（下标值），空表置为-1
} SeqList
~~~
* 链表表示
#### 线性表的基本操作
~~~
线性表的操作包括如下几种
  （1） InitList(& L)
        //构造一个空的线性表 
  （2） DestroyList(& L)
       //线性表存在了，消耗一个线性表
  （3） ClearList（&L ）
       //清空线性表中的内容
  （4） ListEmpty（L）
       //判断线性表是否为空
  （5） ListLength（L）
        //返回线性表的长度
  （6） GetElem（L，i，& e）
        //返回线性表i位置上的元素值，通过e返回     
  （7） PriorElem（L，cur_e,&pre_e）
       //如果cur_e是线性表中的元素，而且不是第一个，那么我们就可以返回该元素前一个元素的值
  （8） NextElem（L，cur_e,&next_e）
       //如果cur_e是线性表中的元素，而且不是最后一个，就返回它下一个元素的值
  （9） Listinsert(&L,i,e)
        //如果线性表存在了，而且i符合条件，则在i位置插入一个元素
  （10）ListDelete（&L,i）
       //删除i位置上的元素
 （11） ListDelete_data(&L,e,order)
      //删除指定的元素e，order决定是删除一个，还是全部。
 （12） Connect_two_List(L_a,L_b,& L_c)
      //连接两个线性表，除去重复的内容    
 （13）print(L)
       //打印线性表    
~~~
* Merge 
~~~
  void Merge(SeqList *LA,SeqList *LB,SeqList *LC){
      int i=0,j=0,k=0;
      while(i<=LA->last&&j<=LB->last){
          if(LA->elem[i]<=LB->elem[j]){
              LC->elem[k]=LA->elem[i];
              i++;
              k++;
          }else{
              LC->elem[k]=LB->elem[j];
              i++;
              k++;
          }
      }
      while(i<=LA->last)｛
           LC->elem[k]=LA->elem[i];
      ｝
      while(j<=LB->last)｛
           LC->elem[k]=LB->elem[j];
      ｝
      LC->last=LA->last+LB->last;
  } 
~~~
#### 一元稀疏多项式
* 类型定义
~~~
typedef struct{
    float coef； // 系数
    int expn；   // 指数
} ElemType，Term； // 项
typedef struct{
    Term *elem；  // 存储空间基址
    int length；  // 长度（项数）
}Poly  /// 一元稀疏多项式
~~~
* 构建一元稀疏多项式
~~~
Status CreatePoly(Poly &p,Term e[],int n){
    int i;
    P.elem = (Tern*)malloc(sizeof(Term)*n)'
    if(p.elem==NULL){
        return OVERFLOW;
    }
    for(i=0;i<n;i++){
        p.elem[i]=e[i];
    }
    p.length=n;
    return OK;
}
~~~
* 一元稀疏多项式的加法
~~~
Status AddPoly(Poly pa,Poly pb,Poly &pc){
    // 求pc=pa+pb
    int i=0,j=0,k=0;
    float c;
    pc.elem=(Term*)malloc((pa.length+pb.length))*sizeof(Term));
    if(Null==pc.elem){
        return OVERFLOW;
    }
    while(i<pa.length&&j<pb.length){
        // 两个多项式未处理结束
        if(pa.elem[i].expn<pb.elem[i].expn){
            // pa项的指数较小，添加到pc
            pc.elem[k++]=pb.elem[j++];
        }else{
            // 指数相等
            c=pa.elem[i].coef+pb.elem[j].coef;//系数相等
            if(c!=0){
                // 系数和不为0，构建和项，并添加到pc
                pc.elem[k].expn=pa.elem[i].expn;
                pc.elem[k].coef=c;
                k++;
            }
            // pa和pb均取下一项
            i++;
            j++;
        }
        if(i==pa.length){
            // pa已处理完，将pb剩余部分添加到pc
            while（jMpb.length){
                pc.elem[k++]=pb.elem[j++];
            }
        }
        if(j==pb.length){
            while(i<pa.length){
                pc.elem[k++]=pa.elem[i++];
           }
        }
        if(k<pa.length+pb.length){
            if(NULL==(pc.elem=(Term*)realloc(pc.elem,lk*sizeof(Term))){
                return OBERFLOW;
            }
        }
        pc.length=k;
        return OK;
    }
}
~~~
### 栈
栈作为一种限定性线性表，将线性表的插入和删除运算限制为仅在表的一端进行。
通常将表中允许进行插入、删除操作的一端称为栈顶，表的另一端被称为栈底。











本文参考：

* https://www.jianshu.com/p/75425f405c25
* https://blog.csdn.net/yishizuofei/article/details/76166183