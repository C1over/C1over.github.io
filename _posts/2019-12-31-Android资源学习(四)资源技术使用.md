---
layout:     post   				    
title:      Android资源学习(四)资源技术使用
subtitle:   Android资源学习系列   #副标题
date:       2019-12-31		   	# 时间
author:     Cc1over				# 作者
header-img: img/post-bg-keybord.jpg              #这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - Android资源学习系列
---

# Android资源学习(四)资源技术使用

## 前言

读Android9.0的源码，从资源编译到资源管理器初始化到资源查找，学习了Android对读取的优化，对代码结构的设计，对缓存方式的设计等等，但是其实不管黑猫还是白猫，能用在项目里的才是好猫，所以，笔者才想写一篇Android资源相关技术的使用以及框架，然后持续更新对应框架的源码阅读笔记

## # 换肤

动态换肤方案的几个关注点：

* 无需继承，在Application中init就能使用的设计架构
* 如果标记View ？
* 如何实现资源id的对应关系
* **资源合并**：这个是我最想从换肤框架去学习的，那所有的资源文件合并成同一个大文件，自定义资源解析和管理的设计

## # 资源热修复

资源热修复的本质其实就是在资源更改之后通过下发补丁包到线上，所以资源热修复其实可以分为2个部分：

* **补丁包的生成**
* **补丁包下发成功后的处理**

###  补丁包下发成功后的处理

构造一个新的**AssetManager**，并通过反射调用**addAssetPath**方法，把这个完整的新资源包加入到**AssetManager**中，以这种方式得到一个含有所有新资源的**AssetManager**

方案代表：

* **Instance Run**
* **Tinker**

构造一个异于0x7f的package id的资源包，然后在这个包里只放包含改变了的资源项，然后直接在原来的**AssetManager**中**addAssetPath**添加这个包，处理情况为：

* **增加资源：**直接加入补丁包，然后在新代码里直接引用
* **删除资源：**本地资源包不处理，直接不引用
* **修改资源：**与**增加资源**类似直接加入补丁包，然后引用处改为新id

方案代表：

* **Sophix**

利用**PackageManager**的**getResourcesForApplication**方法生成补丁包Resources对象，避免调用**AssetManager** 中的非SDK方法**addAssetPath**

方案代表：

* **Stark** 

### 补丁包的生成

补丁包的生成主要分为两种

* 全量：将所有的资源放入补丁中
* 增量：只把发生改变的资源放入补丁中

> 增量补丁包存在的问题

资源文件我们可以差量的方式把改动过的文件拷贝到补丁apk中，那resources.arsc怎么办呢？如何去生成差量的resources.arsc文件？主要总结方案为：

* 改造aapt：在它收集所有的资源并且生成了R文件之后，我们通过传入一份文件（里面包含改变过的资源索引）来动态的移除ReasourceTable中没有改变过的资源，这样最终生成的arsc文件就是增量的 
* 改造aapt：
  * 在aapt中存在–split这样一个命令。我们可以通过改造这个命令去实现需求
  *  我们都知道Android的系统资源是不会被加到arsc文件中的，具体的aapt命令为-I，那我们是不是也可以通过再造aapt，去把我们没有修改过的资源也像系统资源一样不添加到arsc中呢？ 
* 我们甚至可以绕开aapt，不用它转而自己去生成arsc文件，主要的逻辑都是ResourceTable.cpp的flatten方法中，可以照葫芦画瓢嘛 

接下来我的计划就是做一系列的源码源码解析，从源码里面看实现



参考资料：

[记一次苦逼的逆向分析经历](<http://zjutkz.net/2016/05/15/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%8B%A6%E9%80%BC%E7%9A%84%E8%B5%84%E6%BA%90%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/>)