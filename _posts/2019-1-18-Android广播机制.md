---
layout:     post   				    
title:      Android广播机制		 
subtitle:   framework    #副标题
date:       2019-1-17			   	# 时间
author:     Cc1over				# 作者
header-img: img/home-bg-o.jpeg	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - android
    - framework
---

## Android广播机制

广播机制对于我们Android开发者来说并不陌生，最近笔者听身边的小伙伴讲了一下EventBus的实现原理，发现原来EventBus的内部是基于反射实现的，所以对于Android原生的广播机制充满了兴趣，本文笔者将记录笔者学习广播机制的学习过程<br>

上一篇[Android中的Context](https://c1over.github.io/2019/01/16/Context/)也讲述了Android中四大组件的关系，所以本文将以ContextWrapper的registerReceiver()为入口，开始解析整个广播机制

#### 广播注册流程

##### [-> ContextWrapper.registerReceiver]

```java
public class ContextWrapper extends Context {
   @Override
	public Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter) {
		return mBase.registerReceiver(receiver, filter);
	}
}    
```

##### [-> ContextImp.registerReceiver]

```java
public Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter) {
    return registerReceiver(receiver, filter, null, null);
}

public Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler) {
    return registerReceiverInternal(receiver, getUserId(),
            filter, broadcastPermission, scheduler, getOuterContext());
}
```

参数解析：

* broadcastPermission：广播的权限控制
* scheduler：指定接收到广播时onRecive执行线程，当scheduler=null则默认代表在主线程中执行

##### [-> ContextImp.registerReceiverInternal]

```java
private Intent registerReceiverInternal(BroadcastReceiver receiver, int userId, IntentFilter filter, String broadcastPermission, Handler scheduler, Context context) {
    IIntentReceiver rd = null;
    if (receiver != null) {
        if (mPackageInfo != null && context != null) {
            if (scheduler == null) {
                //将主线程Handler赋予scheuler
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(
                receiver, context, scheduler,
                mMainThread.getInstrumentation(), true);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(
                  receiver, context, scheduler, null, true).getIIntentReceiver();
        }
    }
    try {
        return ActivityManagerNative.getDefault().registerReceiver(
                mMainThread.getApplicationThread(), mBasePackageName,
                rd, filter, broadcastPermission, userId);
    } catch (RemoteException e) {
        return null;
    }
}
```

和之前解析过的[startService启动过程](https://c1over.github.io/2019/01/17/startService%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/)很相似，这里通过ActivityManagerNative拿到的是ActivityManagerProxy对象，然后也是也是老套路了，传一个ApplicationThread过去，然后构成system_service进程与用户进程的相互通信

##### [-> ActivityManagerProxy.registerReceiver]

```java
public Intent registerReceiver(IApplicationThread caller, String packageName, IIntentReceiver receiver, IntentFilter filter, String perm, int userId) throws RemoteException {
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IActivityManager.descriptor);
    data.writeStrongBinder(caller != null ? caller.asBinder() : null);
    data.writeString(packageName);
    data.writeStrongBinder(receiver != null ? receiver.asBinder() : null);
    filter.writeToParcel(data, 0);
    data.writeString(perm);
    data.writeInt(userId);

    //Command为REGISTER_RECEIVER_TRANSACTION
    mRemote.transact(REGISTER_RECEIVER_TRANSACTION, data, reply, 0);
    reply.readException();
    Intent intent = null;
    int haveIntent = reply.readInt();
    if (haveIntent != 0) {
        intent = Intent.CREATOR.createFromParcel(reply);
    }
    reply.recycle();
    data.recycle();
    return intent;
}
```

这里和startService那个过程稍微有点不一样，它除了ApplicationThread之外还多传了一个receiver的Binder对象，所以我们现在回头留意一下这个receiver的构建过程，看看它到时是什么，然后等等进入AMS那边之后再重点关注

##### 返回[-> ContextImp.registerReceiverInternal]

```java
rd = new LoadedApk.ReceiverDispatcher(
                  receiver, context, scheduler, null, true).getIIntentReceiver();
```

LoadedApk的创建过程其实是在ContextImp中的中，而LoadedApk其实就是.apk在内存中的数据结构

##### [-> LoadedApk.ReceiverDispatcher.getIIntentReceiver]

```java
  IIntentReceiver getIIntentReceiver() {
         return mIIntentReceiver;
  }
```

##### [-> ReceiverDispatcher]

```java
ReceiverDispatcher(BroadcastReceiver receiver, Context context,
        Handler activityThread, Instrumentation instrumentation,
        boolean registered) {
    mIIntentReceiver = new InnerReceiver(this, !registered);
    mReceiver = receiver;
    mContext = context;
    mActivityThread = activityThread;
    mInstrumentation = instrumentation;
    mRegistered = registered;
    mLocation = new IntentReceiverLeaked(null);
    mLocation.fillInStackTrace();
}
```

##### [->new InnerReceiver]

```java
final static class InnerReceiver extends IIntentReceiver.Stub {
    final WeakReference<LoadedApk.ReceiverDispatcher> mDispatcher;
    final LoadedApk.ReceiverDispatcher mStrongRef;

    InnerReceiver(LoadedApk.ReceiverDispatcher rd, boolean strong) {
        mDispatcher = new WeakReference<LoadedApk.ReceiverDispatcher>(rd);
        mStrongRef = strong ? rd : null;
    }
    ...
}
```

ReceiverDispatcher有一个内部类InnerReceiver，这个类继承自IIntentReceiver.Stub，这是一个Binder服务端，而这里显然是用于通信，而关于它和ApplicationThread之间有什么作用上的区别，这里暂时看不出来，我们把悬念留到后面，然后进入system_service端

##### [-> ActivityManagerService.registerReceiver]

```java
public Intent registerReceiver(IApplicationThread caller, String callerPackage,
        IIntentReceiver receiver, IntentFilter filter, String permission, int userId) {
    ArrayList<Intent> stickyIntents = null;
    ProcessRecord callerApp = null;
    ...
    synchronized(this) {
        if (caller != null) {
            callerApp = getRecordForAppLocked(caller);
            ...
            callingUid = callerApp.info.uid;
            callingPid = callerApp.pid;
        } else {
            callerPackage = null;
            callingUid = Binder.getCallingUid();
            callingPid = Binder.getCallingPid();
        }

        userId = handleIncomingUser(callingPid, callingUid, userId,
                true, ALLOW_FULL_ONLY, "registerReceiver", callerPackage);

        //获取IntentFilter中的actions. 这就是平时所加需要监听的广播action
        Iterator<String> actions = filter.actionsIterator();
        if (actions == null) {
            ArrayList<String> noAction = new ArrayList<String>(1);
            noAction.add(null);
            actions = noAction.iterator();
        }

        int[] userIds = { UserHandle.USER_ALL, UserHandle.getUserId(callingUid) };
        while (actions.hasNext()) {
            String action = actions.next();
            for (int id : userIds) {
                //从mStickyBroadcasts中查看用户的sticky Intent
                ArrayMap<String, ArrayList<Intent>> stickies = mStickyBroadcasts.get(id);
                if (stickies != null) {
                    ArrayList<Intent> intents = stickies.get(action);
                    if (intents != null) {
                        if (stickyIntents == null) {
                            stickyIntents = new ArrayList<Intent>();
                        }
                        //将sticky Intent加入到队列
                        stickyIntents.addAll(intents);
                    }
                }
            }
        }
    }
    ArrayList<Intent> allSticky = null;
    if (stickyIntents != null) {
        final ContentResolver resolver = mContext.getContentResolver();
        for (int i = 0, N = stickyIntents.size(); i < N; i++) {
            Intent intent = stickyIntents.get(i);
            if (filter.match(resolver, intent, true, TAG) >= 0) {
                if (allSticky == null) {
                    allSticky = new ArrayList<Intent>();
                }
                //匹配成功，则将给intent添加到allSticky队列
                allSticky.add(intent);
            }
        }
    }

    //当IIntentReceiver为空，则直接返回第一个sticky Intent，
    Intent sticky = allSticky != null ? allSticky.get(0) : null;
    if (receiver == null) {
        return sticky;
    }

    synchronized (this) {
        if (callerApp != null && (callerApp.thread == null
                || callerApp.thread.asBinder() != caller.asBinder())) {
            return null; //调用者已经死亡
        }
        ReceiverList rl = mRegisteredReceivers.get(receiver.asBinder());
        if (rl == null) {
            //对于没有注册的广播，则创建接收者队列
            rl = new ReceiverList(this, callerApp, callingPid, callingUid,
                    userId, receiver);
            if (rl.app != null) {
                rl.app.receivers.add(rl);
            } else {
                receiver.asBinder().linkToDeath(rl, 0); //注册死亡通知
                ...
                rl.linkedToDeath = true;
            }
            //新创建的接收者队列，添加到已注册广播队列。
            mRegisteredReceivers.put(receiver.asBinder(), rl);
        }
        ...
        //创建BroadcastFilter对象，并添加到接收者队列
        BroadcastFilter bf = new BroadcastFilter(filter, rl, callerPackage,
                permission, callingUid, userId);
        rl.add(bf);
        //新创建的广播过滤者，添加到ReceiverResolver队列
        mReceiverResolver.addFilter(bf);

        //所有匹配该filter的sticky广播执行入队操作
        //如果没有使用sendStickyBroadcast，则allSticky=null。
        if (allSticky != null) {
            ArrayList receivers = new ArrayList();
            receivers.add(bf);

            final int stickyCount = allSticky.size();
            for (int i = 0; i < stickyCount; i++) {
                Intent intent = allSticky.get(i);
                BroadcastQueue queue = broadcastQueueForIntent(intent);
                //创建BroadcastRecord
                BroadcastRecord r = new BroadcastRecord(queue, intent, null,
                        null, -1, -1, null, null, AppOpsManager.OP_NONE, null, receivers,
                        null, 0, null, null, false, true, true, -1);
                //该广播加入到并行广播队列
                queue.enqueueParallelBroadcastLocked(r);
                //调度广播，发送BROADCAST_INTENT_MSG消息，触发处理下一个广播。
                queue.scheduleBroadcastsLocked();
            }
        }
        return sticky;
    }
}
```

在解析这个方法前，这个方法有点长，但是没有关系，我们一步一步去分析，ps->由于Android5.0之后系统不再推荐使用粘性广播，所以笔者这里的分析会忽略粘性广播的实现：

* 获取调用程序的进程信息ProcessRecord及PID和Uid，这里的ProcessRecord就是AMS中用来描述应用进程的数据结构
* receiver是IIntentReceiver类型的变量，上面只看传输过程我们还有一个问题没有解决，就是ApplicationThread和receiver的区别，ApplicationThread就是广播发送的进程，receiver就是广播接受端的进程，在ActivityManagerService中则是用一个map去保存这些信息，key就是receiver.asBinder，value就是一个ReceiverList接受者列表，样应用进程的一个Receiver就和AMS服务中的一个ReceiverList关联起来了
* 在BroadcastQueue中有两个广播队列mParallelBroadcasts,mOrderedBroadcasts，数据类型都为ArrayList：
  * **mParallelBroadcasts**:并行广播队列，可以立刻执行，而无需等待另一个广播运行完成，该队列只允许动态已注册的广播，从而避免发生同时拉起大量进程来执行广播，前台的和后台的广播分别位于独立的队列
  
  * **mOrderedBroadcasts**：有序广播队列，同一时间只允许执行一个广播，该队列顶部的广播便是活动广播，其他广播必须等待该广播结束才能运行，也是独立区别前台的和后台的广播

##### 小结

梳理上面的方法流程：

* 注册广播传递的参数为广播接收者BroadcastReceiver和Intent过滤条件IntentFilter
* 创建对象LoadedApk.ReceiverDispatcher.InnerReceiver，该对象继承于IIntentReceiver.Stub
* 通过AMS把当前进程的ApplicationThread和InnerReceiver对象的代理类，注册登记到system_server进程
* 当广播receiver没有注册过，则创建广播接收者队列ReceiverList，该对象继承于ArrayList， 并添加到AMS.mRegisteredReceivers(已注册广播队列)
* 创建BroadcastFilter，并添加到AMS.mReceiverResolver
* 将BroadcastFilter添加到该广播接收者的ReceiverList

#### 发送广播

发送广播的流程我们以ContextImp的sendBroadcast方法为如口，每次先看wrapper都是mBase.XXX，太没意思了，所以从ContextImp开始：

##### [-> ContextImp.sendBroadcast]

```java
public void sendBroadcast(Intent intent) {
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess();
        ActivityManagerNative.getDefault().broadcastIntent(
                mMainThread.getApplicationThread(), intent, resolvedType, null,
                Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false,
                getUserId());
    } catch (RemoteException e) {
        ...
    }
}
```

老规矩了，直接到ActivityManagerProxy，这里没啥好说的了

##### [-> ActivityManagerProxy.broadcastIntent]

```java
public int broadcastIntent(IApplicationThread caller, Intent intent, String resolvedType, IIntentReceiver resultTo, int resultCode, String resultData, Bundle map, String[] requiredPermissions, int appOp, Bundle options, boolean serialized, boolean sticky, int userId) throws RemoteException {
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IActivityManager.descriptor);
    data.writeStrongBinder(caller != null ? caller.asBinder() : null);
    intent.writeToParcel(data, 0);
    data.writeString(resolvedType);
    data.writeStrongBinder(resultTo != null ? resultTo.asBinder() : null);
    data.writeInt(resultCode);
    data.writeString(resultData);
    data.writeBundle(map);
    data.writeStringArray(requiredPermissions);
    data.writeInt(appOp);
    data.writeBundle(options);
    data.writeInt(serialized ? 1 : 0);
    data.writeInt(sticky ? 1 : 0);
    data.writeInt(userId);

    //Command为BROADCAST_INTENT_TRANSACTION
    mRemote.transact(BROADCAST_INTENT_TRANSACTION, data, reply, 0);
    reply.readException();
    int res = reply.readInt();
    reply.recycle();
    data.recycle();
    return res;
}
```

写入参数然后IPC过程，这里都是些熟悉的参数了，然后我们就到system_service端的ActivityManagerService啦

##### [-> ActivityManagerService.broadcastIntent]

```java
public final int broadcastIntent(IApplicationThread caller, Intent intent, String resolvedType, IIntentReceiver resultTo, int resultCode, String resultData, Bundle resultExtras, String[] requiredPermissions, int appOp, Bundle options, boolean serialized, boolean sticky, int userId) {
    enforceNotIsolatedCaller("broadcastIntent");
    synchronized(this) {
        //验证广播intent是否有效
        intent = verifyBroadcastLocked(intent);
        //获取调用者进程记录对象
        final ProcessRecord callerApp = getRecordForAppLocked(caller);
        final int callingPid = Binder.getCallingPid();
        final int callingUid = Binder.getCallingUid();
        final long origId = Binder.clearCallingIdentity();
        int res = broadcastIntentLocked(callerApp,
                callerApp != null ? callerApp.info.packageName : null,
                intent, resolvedType, resultTo, resultCode, resultData, resultExtras,
                requiredPermissions, appOp, null, serialized, sticky,
                callingPid, callingUid, userId);
        Binder.restoreCallingIdentity(origId);
        return res;
    }
}
```

broadcastIntent()方法有两个布尔参数serialized和sticky来共同决定是普通广播，有序广播，还是Sticky广播，参数如下：

| 类型                 | serialized | sticky |
| -------------------- | ---------- | ------ |
| sendBroadcast        | false      | false  |
| sendOrderedBroadcast | true       | false  |
| sendStickyBroadcast  | false      | true   |

OK，来到这里，下面的流程笔者就简便带过，不再贴过多的源码，主要是梳理流程，总结源码中一些细致的点，以及关键关注一下，AMS给制定进程发送广播的源码分析：

* 设置广播flag
  * 对广播增加一个flag，保证已停止app不会收到该广播
  * 当没有启动完成时，不允许启动新进程
  * 检查发送广播时用户状态，如果用户状态不处于Running状态的话，只能发送系统升级广播或关机广播
* 广播权限验证
  * 对于某些只允许系统使用的广播，抛出异常
  * 限定某些涉及安全性的广播只能发给自己
* 处理系统广播
  * 非系统广播略过
* 查询receivers和registeredReceivers
  * receivers：记录着匹配当前intent的所有静态注册广播接收者
  * registeredReceivers：记录着匹配当前的所有动态注册的广播接收者
* 处理并行广播
  * 通过mParallelBroadcasts这个ArrayList成员，取出然后添加到队列BroadcastQueue中
  * 然后调用队列scheduleBroadcastsLocked
* 合并receivers和registeredReceivers
  * 动态注册的registeredReceivers，全部合并都receivers，再统一按串行方式处理

* 处理串行广播
  * 通过mOrderBroadcasts这个ArrayList成员，取出然后添加到队列BroadcastQueue中
  * 然后调用队列scheduleBroadcastsLocked

来到这里之后，剩下的工作AMS就转交给了BroadcastQueue这个队列，这里我们重点关注，处理流程：

##### [BroadcastQueue.scheduleBroadcastsLocked]

```java
public void scheduleBroadcastsLocked() {
    // 正在处理BROADCAST_INTENT_MSG消息
    if (mBroadcastsScheduled) {
        return;
    }
    //发送BROADCAST_INTENT_MSG消息
    mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this));
    mBroadcastsScheduled = true;
}
```

##### [-> mHandler.handleMessage]

```java
private final class BroadcastHandler extends Handler {

    public void handleMessage(Message msg) {
        switch (msg.what) {
            case BROADCAST_INTENT_MSG: {
                processNextBroadcast(true); 
            } break;
            ...
    }
}
```

##### [->BroadQueue.processNextBroadcast]

```java
// 处理并行广播
BroadcastRecord r;
mService.updateCpuStats(); //更新CPU统计信息
if (fromMsg)  mBroadcastsScheduled = false;

while (mParallelBroadcasts.size() > 0) {
    r = mParallelBroadcasts.remove(0);
    r.dispatchTime = SystemClock.uptimeMillis();
    r.dispatchClockTime = System.currentTimeMillis();
    final int N = r.receivers.size();
    for (int i=0; i<N; i++) {
        Object target = r.receivers.get(i);
        //分发广播给已注册的receiver 
        deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, false);
    }
    addBroadcastToHistoryLocked(r);//将广播添加历史统计
}
===============================================
// 处理有序广播
...
// step1 判断该进程是否死亡，死亡不发送广播
...
// 正在处理广播的进程保持活跃状态，则继续等待其执行完成 
...
// 所有串行广播处理完成，则调度执行gc  
...
//获取所有该广播所有的接收者
...
//当广播处理时间超时，则强制结束这条广播
...
    if (r.receivers == null || r.nextReceiver >= numReceivers
            || r.resultAbort || forceReceive) {
        if (r.resultTo != null) {
            //处理广播消息消息，调用到onReceive()
performReceiveLocked(r.callerApp, r.resultTo,
                new Intent(r.intent), r.resultCode,
                r.resultData, r.resultExtras, false, false, r.userId);
```

##### [BroadcastQueue.performReceiveLocked]

```java
private static void performReceiveLocked(ProcessRecord app, IIntentReceiver receiver, Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) throws RemoteException {
    //通过binder异步机制，向receiver发送intent
    if (app != null) {
        if (app.thread != null) {
            //调用ApplicationThreadProxy类对应的方法 【4.5】
            app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode,
                    data, extras, ordered, sticky, sendingUser, app.repProcState);
        } else {
            //应用进程死亡，则Recevier并不存在
            throw new RemoteException("app.thread must not be null");
        }
    } else {
        //调用者进程为空，则执行该分支
        receiver.performReceive(intent, resultCode, data, extras, ordered,
                sticky, sendingUser);
    }
}
```

##### [-> ApplicationThreadProxy.scheduleRegisteredReceiver]

```java
public void scheduleRegisteredReceiver(IIntentReceiver receiver, Intent intent, int resultCode, String dataStr, Bundle extras, boolean ordered, boolean sticky, int sendingUser, int processState) throws RemoteException {
    Parcel data = Parcel.obtain();
    data.writeInterfaceToken(IApplicationThread.descriptor);
    data.writeStrongBinder(receiver.asBinder());
    intent.writeToParcel(data, 0);
    data.writeInt(resultCode);
    data.writeString(dataStr);
    data.writeBundle(extras);
    data.writeInt(ordered ? 1 : 0);
    data.writeInt(sticky ? 1 : 0);
    data.writeInt(sendingUser);
    data.writeInt(processState);

    //command=SCHEDULE_REGISTERED_RECEIVER_TRANSACTION
    mRemote.transact(SCHEDULE_REGISTERED_RECEIVER_TRANSACTION, data, null,
            IBinder.FLAG_ONEWAY);
    data.recycle();
}
```

来到这里终于写入数据传输给注册者啦，这里要结合上面的方法一起看，它把这个过程放在循环里面，这样就可以通知所有的接受者。

#### 总结

由于笔者是一个Android的应用开发者，对于Android底层的一些细节没有太多深入，只是重点关注它的流程，但是其实结合上一篇[startService分析](https://c1over.github.io/2019/01/17/startService%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/)笔者觉得其实大体的流程有相似，只是广播这里的处理多了一些队列以及一些调度的过程，整个IPC的过程其实大同小异，而IPC过程不一样的我觉得就是广播机制除了进程通信的ApplicationThread之外还需要多一个Binder那就是receiver，这个Binder主要是用来登记的，而APT才是用来通信的，这可能就是笔者觉得稍微有点不一样的地方







感谢以下作者的努力：

* http://gityuan.com/2016/06/04/broadcast-receiver/
* https://www.jianshu.com/p/dd04e6d97de0?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation