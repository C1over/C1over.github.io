---
layout:     post   				    
title:      生命周期管理		 
subtitle:   android    #副标题
date:       2019-8-6		   	# 时间
author:     Cc1over				# 作者
header-img: img/tag-bg.jpg              #这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - android
---

# 生命周期管理

## 前言

最近一口气把**Walle**和**VasDolly**的源码看完了，收获很多的感觉，下一个任务肯定就是**AndResGuard**了，但是在此之前还是想先写一篇关于生命周期管理的文章，这次的目的主要是从**Glide**生命周期管理开始到**lifeCycle**生命周期管理的分析，最后得到优雅实现生命周期监控的方式

## [Glide-> with]

```java
public static RequestManager with(@NonNull Activity activity) {
    return getRetriever(activity).get(activity);
  }
```

* 看到这里其实发现传进来的activity分别在**getRetriever**和**get**方法中都是入参，从左往右，先看**getRetriever**方法做了什么

## [Glide->  getRetriever]

```java
private static RequestManagerRetriever getRetriever(@Nullable Context context) {
    Preconditions.checkNotNull(context)
    return Glide.get(context).getRequestManagerRetriever();
  }
```

* 来到这个方法其实就不需要往下看了，因为这个入参的类型是**Context**，肯定就没有相关生命周期的处理了，所以回到上一步看**get**方法

```java
public RequestManager get(@NonNull Activity activity) {
    if (Util.isOnBackgroundThread()) {
      return get(activity.getApplicationContext());
    } else {
      assertNotDestroyed(activity);
      android.app.FragmentManager fm = activity.getFragmentManager();
      return fragmentGet(
          activity, fm, /*parentHint=*/ null, isActivityVisible(activity));
    }
  }
```

* 首先判断是否当前运行的线程环境是否为子线程，如果是就调用了重载的**get(Context context)**方法
* 如果不是在子线程，那就判断一下**activity**是否被摧毁，如果这个**activity**已经被摧毁那就抛出一个异常
* 然后就获取**activity**的**FragmentManager**然后调用**fragmentGet**方法得到监听生命周期的fragment

## [RequestManagerRetriever->  fragmentGet]

```java
private RequestManager fragmentGet(@NonNull Context context,
      @NonNull android.app.FragmentManager fm,
      @Nullable android.app.Fragment parentHint,
      boolean isParentVisible) {
    RequestManagerFragment current = getRequestManagerFragment(fm, parentHint, isParentVisible);
    RequestManager requestManager = current.getRequestManager();
    if (requestManager == null) {
      // TODO(b/27524013): Factor out this Glide.get() call.
      Glide glide = Glide.get(context);
      requestManager =
          factory.build(
              glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);
      current.setRequestManager(requestManager);
    }
    return requestManager;
  }
```

* 首先获取到**RequestManagerFragment**
* 然后从上一步拿到的frgment中获取**RequestManager**对象
* 然后用factory构建一个**requestManager**
* 然后就把**requestManager**设置进**RequestManagerFragment**

## [RequestManagerRetriever->  getRequestManagerFragment]

```java
private RequestManagerFragment getRequestManagerFragment(
      @NonNull final android.app.FragmentManager fm,
      @Nullable android.app.Fragment parentHint,
      boolean isParentVisible) {
    RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);
    if (current == null) {
      current = pendingRequestManagerFragments.get(fm);
      if (current == null) {
        current = new RequestManagerFragment();
        current.setParentFragmentHint(parentHint);
        if (isParentVisible) {
          current.getGlideLifecycle().onStart();
        }
        pendingRequestManagerFragments.put(fm, current);
        fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();
        handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();
      }
    }
    return current;
  }
```

* 首先通过FragmentManager去根据**TAG**找到对应的Fragment
* 如果为空就从**pendingRequestManagerFragments**中获取
* 如果还为空就创建这个Fragment
* 然后把Fragment添加到**pendingRequestManagerFragments**中
* **commitAllowingStateLoss**提交
* handler发送消息清除**pendingRequestManagerFragments**中的缓存
* 这种的设计的目的其实就是为了在**commitAllowingStateLoss**失败之后仍然会在容器map中保存住Fragment，以免下次调用这个方法的时候还有重新创建

## [SupportRequestManagerFragment -> 构造方法]

```java
public RequestManagerFragment() {
    this(new ActivityFragmentLifecycle());
  }

  @VisibleForTesting
  @SuppressLint("ValidFragment")
  RequestManagerFragment(@NonNull ActivityFragmentLifecycle lifecycle) {
    this.lifecycle = lifecycle;
  }
```

## [lifeCycle-> 相关] 

```java
 @Override
  public void onStart() {
    super.onStart();
    lifecycle.onStart();
  }

  @Override
  public void onStop() {
    super.onStop();
    lifecycle.onStop();
  }

  @Override
  public void onDestroy() {
    super.onDestroy();
    lifecycle.onDestroy();
    unregisterFragmentWithRoot();
  }
```

* 可以看到这里的设计就是用不可见Fragment监听Activity生命周期
* 然后用lifecycle监听Fragment生命周期
* 这里其实就可以猜测到对外暴露的就是lifecycle

## [ActivityFragmentLifecycle-> 相关] 

```java
void onStart() {
    isStarted = true;
    for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) {
      lifecycleListener.onStart();
    }
  }

  void onStop() {
    isStarted = false;
    for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) {
      lifecycleListener.onStop();
    }
  }

  void onDestroy() {
    isDestroyed = true;
    for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) {
      lifecycleListener.onDestroy();
    }
  }
```

* 和上面的猜想是一致的，通过注册listener的方式给外界监听生命周期的回调

## 阶段小结

整个生命周期管理的流程大概就这样了，然后其实就通过不可见的Fragment去监听Activity的生命周期，然后，通过对外暴露一个LifeCycle的listener让外界也能感知到Activity的生命周期

## [SupportActivity-> getLifeCycle]

```java
public Lifecycle getLifecycle() {
        return this.mLifecycleRegistry;
    }
```

* 平时在**Activity**中获取的Lifecycle其实也是用在Activity的超类**SupportActivity**中获取，所以下一步肯定是看一下mLifecycleRegistry在这个**SupportActivity**中做了什么

```java
@CallSuper
    protected void onSaveInstanceState(Bundle outState) {
        this.mLifecycleRegistry.markState(State.CREATED);
        super.onSaveInstanceState(outState);
    }
```

* 暂时只发现了此处的使用，还不太清晰，回头继续看

## [LifecycleRegistry-> addObserver]

```java
@Override
    public void addObserver(@NonNull LifecycleObserver observer) {
        State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;
        ObserverWithState statefulObserver = new ObserverWithState(observer, initialState);
        ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver);

        if (previous != null) {
            return;
        }
        LifecycleOwner lifecycleOwner = mLifecycleOwner.get();
        if (lifecycleOwner == null) {
            // it is null we should be destroyed. Fallback quickly
            return;
        }

        boolean isReentrance = mAddingObserverCounter != 0 || mHandlingEvent;
        State targetState = calculateTargetState(observer); // 1
        mAddingObserverCounter++;
        while ((statefulObserver.mState.compareTo(targetState) < 0
                && mObserverMap.contains(observer))) {
            pushParentState(statefulObserver.mState);
            statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState));
            popParentState();
            // mState / subling may have been changed recalculate
            targetState = calculateTargetState(observer);
        }

        if (!isReentrance) {
            // we do sync only on the top level.
            sync();
        }
        mAddingObserverCounter--;
    }
```

* 首先先创建了一个initialState和两个ObserveWithState对象
* 然后就判断owner是否为空，是就退出
* 接下来就是两个变量**mAddingObserverCounter**和**mHandlingEvent**分别表示正在添加的数量以及是否正在处理任务，猜测是支持多线程的举动
* 接下来就执行注释1的计算state
* 然后会在一个while循环里面用mState和targetState比较，在当前情况下，只有**DESTROYED**的时候才可能得到负值，所以在**INITIALIZED**的情况下是不会执行这个while循环的
* 然后的操作就是一个同步的操作，由于addObserver当前这种情况下isReentrance为false的

## [LifecycleRegistry-> calculateTargetState]

```java
private State calculateTargetState(LifecycleObserver observer) {
        Entry<LifecycleObserver, ObserverWithState> previous = mObserverMap.ceil(observer);

        State siblingState = previous != null ? previous.getValue().mState : null;
        State parentState = !mParentStates.isEmpty() ? mParentStates.get(mParentStates.size() - 1)
                : null;
        return min(min(mState, siblingState), parentState);
    }
```

* 这里就是从map中获取observer的上一个，然后拿到对应的state
* 然后就在当前状态mState和siblingState和parentState之间拿到最小的的一个，而State是一个枚举类型，比较的其实也只是次序而已
* 这个时候，由于上一步mState经已赋上值就是**INITIALIZED**，其余的siblingState和parentState没有处理过，所以刚进来add第一个接收者的时候这里出去的值应该就是mState的值了

## [enum State]

```java
public enum State {
        /**
         * Destroyed state for a LifecycleOwner. After this event, this Lifecycle will not dispatch
         * any more events. For instance, for an {@link android.app.Activity}, this state is reached
         * <b>right before</b> Activity's {@link android.app.Activity#onDestroy() onDestroy} call.
         */
        DESTROYED,

        /**
         * Initialized state for a LifecycleOwner. For an {@link android.app.Activity}, this is
         * the state when it is constructed but has not received
         * {@link android.app.Activity#onCreate(android.os.Bundle) onCreate} yet.
         */
        INITIALIZED,

        /**
         * Created state for a LifecycleOwner. For an {@link android.app.Activity}, this state
         * is reached in two cases:
         * <ul>
         *     <li>after {@link android.app.Activity#onCreate(android.os.Bundle) onCreate} call;
         *     <li><b>right before</b> {@link android.app.Activity#onStop() onStop} call.
         * </ul>
         */
        CREATED,

        /**
         * Started state for a LifecycleOwner. For an {@link android.app.Activity}, this state
         * is reached in two cases:
         * <ul>
         *     <li>after {@link android.app.Activity#onStart() onStart} call;
         *     <li><b>right before</b> {@link android.app.Activity#onPause() onPause} call.
         * </ul>
         */
        STARTED,

        /**
         * Resumed state for a LifecycleOwner. For an {@link android.app.Activity}, this state
         * is reached after {@link android.app.Activity#onResume() onResume} is called.
         */
        RESUMED;

        /**
         * Compares if this State is greater or equal to the given {@code state}.
         *
         * @param state State to compare with
         * @return true if this State is greater or equal to the given {@code state}
         */
        public boolean isAtLeast(@NonNull State state) {
            return compareTo(state) >= 0;
        }
    }
```

## [LifecycleRegistry-> sync]

```java
private void sync() {
        while (!isSynced()) {
            mNewEventOccurred = false;
            // no need to check eldest for nullability, because isSynced does it for us.
            if (mState.compareTo(mObserverMap.eldest().getValue().mState) < 0) {
                backwardPass(lifecycleOwner);
            }
            Entry<LifecycleObserver, ObserverWithState> newest = mObserverMap.newest();
            if (!mNewEventOccurred && newest != null
                    && mState.compareTo(newest.getValue().mState) > 0) {
                forwardPass(lifecycleOwner);
            }
        }
        mNewEventOccurred = false;
    }
```

* 这段代码暂时看得有点迷，但是现在可以知道的点就是现在这种情况下eldest和mState应该是相等的，待定等等再详看

## [LifecycleRegistry-> addObserver]

```java
@Override
    public void addObserver(@NonNull LifecycleObserver observer) {
       
        State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;
        ObserverWithState statefulObserver = new ObserverWithState(observer, initialState);
        ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver);
        
        boolean isReentrance = mAddingObserverCounter != 0 || mHandlingEvent;  // 1
        State targetState = calculateTargetState(observer); 
        mAddingObserverCounter++;

        if (!isReentrance) {
            // we do sync only on the top level.
            sync();
        }
        mAddingObserverCounter--;
    }
```

- 这个方法里有不少步骤还是不太清晰，但是可以把当前情况执行的代码过滤出来
- 疑点1：两个参数的作用
- 疑点2：sync的作用
- 往下的思路：mObserverMap必有后用，现在应该先看一下注册完Observer添加到容器之后，执行任务的时候是怎么实现的
- 这个时候其实发现之前的思路断开了，在这个类里面找不到执行的方法，所以回头看遗漏

## [SupportActivity-> onCreate]

```java
protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        ReportFragment.injectIfNeededIn(this);
    }
```

* 第一次看的时候忽略的onCreate方法中这个ReportFragment的调用的静态方法，其实看到这里就可以大胆猜想，这个实现和Glide可能是大同小异的

## [ReportFragment-> injectIfNeededIn]

```java
public static void injectIfNeededIn(Activity activity) {
        // ProcessLifecycleOwner should always correctly work and some activities may not extend
        // FragmentActivity from support lib, so we use framework fragments for activities
        android.app.FragmentManager manager = activity.getFragmentManager();
        if (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == null) {
            manager.beginTransaction().add(new ReportFragment(), REPORT_FRAGMENT_TAG).commit();
            // Hopefully, we are the first to make a transaction.
            manager.executePendingTransactions();
        }
    }
```

* 猜测完美命中，但是现在问题是没有明确的把这个Fragment和刚刚没分析完的addObserver方法关联起来
* 于是瞄准生命周期函数，发现最终都调用了dispatch方法

## [ReportFragment-> dispatch]

```java
private void dispatch(Lifecycle.Event event) {
        Activity activity = getActivity();
        if (activity instanceof LifecycleRegistryOwner) {
            ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event);
            return;
        }

        if (activity instanceof LifecycleOwner) {
            Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();
            if (lifecycle instanceof LifecycleRegistry) {
                ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);
            }
        }
    }
```

* 回忆起前面的**SupportActivity**，它实现了**LifecycleOwner**接口
* 所以其实它会执行的是**LifecycleRegistry**的**handleLifecycleEvent**方法

## [LifecycleRegistry-> handleLifecycleEvent]

```java
public void handleLifecycleEvent(@NonNull Lifecycle.Event event) {
        State next = getStateAfter(event);
        moveToState(next);
    }
```

## [LifecycleRegistry-> getStateAfter]

```java
static State getStateAfter(Event event) {
        switch (event) {
            case ON_CREATE:
            case ON_STOP:
                return CREATED;
            case ON_START:
            case ON_PAUSE:
                return STARTED;
            case ON_RESUME:
                return RESUMED;
            case ON_DESTROY:
                return DESTROYED;
            case ON_ANY:
                break;
        }
        throw new IllegalArgumentException("Unexpected event value " + event);
    }
```

## [LifecycleRegistry-> moveToState]

```java
private void moveToState(State next) {
        if (mState == next) {
            return;
        }
        mState = next;
        if (mHandlingEvent || mAddingObserverCounter != 0) {
            mNewEventOccurred = true;
            // we will figure out what to do on upper level.
            return;
        }
        mHandlingEvent = true;
        sync();
        mHandlingEvent = false;
    }
```

* 又看到了熟悉的变量**mHandlingEvent**和**mAddingObserverCounter**，也就是说他其实是一种限制，限制同一时间内，只能执行一个event和添加一个Observer
* 如果正在有Event或者新的注册者进来，就先用mNewEventOccurred**这个标记位记录，然后就不处理了，可能后续有操作
* 然后就继续调用sync方法

## [LifecycleRegistry-> sync]

```java
private void sync() {
        while (!isSynced()) { // 1
            mNewEventOccurred = false;
            // no need to check eldest for nullability, because isSynced does it for us.
            if (mState.compareTo(mObserverMap.eldest().getValue().mState) < 0) {
                backwardPass(lifecycleOwner);
            }
            Entry<LifecycleObserver, ObserverWithState> newest = mObserverMap.newest();
            if (!mNewEventOccurred && newest != null
                    && mState.compareTo(newest.getValue().mState) > 0) {
                forwardPass(lifecycleOwner);
            }
        }
        mNewEventOccurred = false;
    }
```

* **mNewEventOccurred** = false;
* 这里的设计就是首先和eldest比较是否<0，而其实Map中的首元素是**INITIALIZED**，<0的状态就是**DESTROYED**了，然后执行**backwardPass**方法
* 而如果不是这种情况，就把当前的状态和最新的状态比较>0，就用**forwardPass**方法执行变化

## [LifecycleRegistry-> isSynced]

```java
private boolean isSynced() {
        if (mObserverMap.size() == 0) {
            return true;
        }
        State eldestObserverState = mObserverMap.eldest().getValue().mState;
        State newestObserverState = mObserverMap.newest().getValue().mState;
        return eldestObserverState == newestObserverState && mState == newestObserverState;
    }
```

* 这里其实还是符合我们之前的推测，就是**mObserverMap**必有后用，只不过没想到他是这样用而已
* 判断isSynced的本质就是判断容器的最后一个和第一个，以及当前状态和最新的状态是否一致，而由于上面**moveToState**已经把mState赋值为Fragment中的下一个状态，显然这个是false的，而&&前面的判断估计就是用来处理初始化的情况吧

## [LifecycleRegistry-> backwardPass]

```java
private void backwardPass(LifecycleOwner lifecycleOwner) {
        Iterator<Entry<LifecycleObserver, ObserverWithState>> descendingIterator =
                mObserverMap.descendingIterator();
        while (descendingIterator.hasNext() && !mNewEventOccurred) {
            Entry<LifecycleObserver, ObserverWithState> entry = descendingIterator.next();
            ObserverWithState observer = entry.getValue();
            while ((observer.mState.compareTo(mState) > 0 && !mNewEventOccurred
                    && mObserverMap.contains(entry.getKey()))) {
                Event event = downEvent(observer.mState);
                pushParentState(getStateAfter(event));
                observer.dispatchEvent(lifecycleOwner, event); // 1
                popParentState();
            }
        }
    }
```

## [ObserverWithState-> dispatchEvent]

```java
void dispatchEvent(LifecycleOwner owner, Event event) {
            State newState = getStateAfter(event);
            mState = min(mState, newState);
            mLifecycleObserver.onStateChanged(owner, event);
            mState = newState;
        }
```

* 最终在这里调用了Observer的回调

## [LifecycleRegistry-> addObserver]

```java
@Override
    public void addObserver(@NonNull LifecycleObserver observer) {
        State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;
        ObserverWithState statefulObserver = new ObserverWithState(observer, initialState);
        ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver);

        if (previous != null) {
            return;
        }
        LifecycleOwner lifecycleOwner = mLifecycleOwner.get();
        if (lifecycleOwner == null) {
            // it is null we should be destroyed. Fallback quickly
            return;
        }

        boolean isReentrance = mAddingObserverCounter != 0 || mHandlingEvent;
        State targetState = calculateTargetState(observer); // 1
        mAddingObserverCounter++;
        while ((statefulObserver.mState.compareTo(targetState) < 0
                && mObserverMap.contains(observer))) {
            pushParentState(statefulObserver.mState);
            statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState));
            popParentState();
            // mState / subling may have been changed recalculate
            targetState = calculateTargetState(observer);
        }

        if (!isReentrance) {
            // we do sync only on the top level.
            sync();
        }
        mAddingObserverCounter--;
    }
```

- 回顾刚刚疑问重重的这个方法，while循环的处理的操作其实就是害怕当在注册一个Observer的时候状态改变没有通知到，所以这里的逻辑其实就是想在注册的时候通知它除了**DESTROYED**之外的改变的状态
- 而两个变量**mAddingObserverCounter**和**mHandlingEvent**如前面所说的一致，是描述一种限制，现在同一时间只能添加一个Observer和执行一个Event，如果标记位检测到了发生在添加Observer或者正在执行一个Event，那么放弃同步的操作，否则有可能在初始化，执行变化的期间又出现了状态的变化，这个时候才需要去同步一波

## 总结

* 监听生命周期的核心就是往activity中添加不可见的Fragment
* 而对外的接口都是有一个代理的类再去监听Fragment的生命周期变化，再对外暴露
* 而Glide采用的是接口的形式，Lifecycle多采用了一种注解的形式实现
* 而像google 的 Lifecycle提供的处理方式更加细节，考虑到了各种各样状态变化和添加观察者以及通知更新的操作，所以读起来比较难